package org.neo4j.kernel.store.format.dsl;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collection;

import com.sun.codemodel.internal.CodeWriter;
import com.sun.codemodel.internal.JClassAlreadyExistsException;
import com.sun.codemodel.internal.JCodeModel;
import com.sun.codemodel.internal.JDefinedClass;
import com.sun.codemodel.internal.JPackage;
import org.neo4j.kernel.util.Pair;

import static org.neo4j.kernel.util.Pair.pair;

/**
 * The storeformat DSL is a Java DSL for generating serialization and deserialization code, similar to code-generating
 * serialization libraries like Protocol Buffers.
 *
 * It differs from other libraries in a few aspects:
 *
 * <ul>
 *     <li>It is optimized for serializing and deserializing from and to memory mapped files</li>
 *     <li>It provides random-access reading and writing to fields in each record, the entire record does
 *         not have to be read or written to to change individual fields.</li>
 *     <li>It is garbage free</li>
 * </ul>
 */
public class StoreFormat
{
    private final Collection<ItemDefinition> itemDefinitions = new ArrayList();
    private final JCodeModel codeModel = new JCodeModel();
    private final String name;

    public StoreFormat( String name )
    {
        this.name = name;
    }

    public ItemDefinition defineItem( String name )
    {
        ItemDefinition itemDefinition = new ItemDefinition( name );
        itemDefinitions.add( itemDefinition );
        return itemDefinition;
    }

    /** Generate relevant classes for the storage format.
     *  Returns tuples of class name -> class contents */
    public Collection<Pair<String, String>> build()
    {
        try
        {
            JDefinedClass formatClass = codeModel._class( name );
            formatClass.javadoc().add( "WARNING: This file is automatically generated, do not change this file, your changes will be overwritten." );

            for ( ItemDefinition itemDefinition : itemDefinitions )
            {
                itemDefinition.contributeToClass( formatClass );
            }

            final Collection<Pair<String, String>> classes = new ArrayList();
            codeModel.build( new CodeWriter(){

                private final Collection<Pair<String, ByteArrayOutputStream>> outputs = new ArrayList();

                @Override
                public OutputStream openBinary( JPackage jPackage, String className ) throws IOException
                {
                    String fullName = jPackage.name() + "." + className.replace( ".java", "" );
                    for ( Pair<String, ByteArrayOutputStream> output : outputs )
                    {
                        if(output.first().equals( fullName ))
                        {
                            return output.second();
                        }
                    }

                    ByteArrayOutputStream out = new ByteArrayOutputStream(  );
                    outputs.add( pair( fullName, out ) );
                    return out;
                }

                @Override
                public void close() throws IOException
                {
                    for ( Pair<String, ByteArrayOutputStream> output : outputs )
                    {
                        classes.add( pair( output.first(), output.second().toString( "UTF-8" ) ) );
                        output.second().close();
                    }
                    outputs.clear();
                }
            } );

            return classes;
        }
        catch ( JClassAlreadyExistsException e )
        {
            throw new RuntimeException( e );
        }
        catch ( IOException e )
        {
            throw new RuntimeException( e );
        }
    }

    public String name()
    {
        return name;
    }
}
